using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Oak.Domain.Data
{
    /// <summary>
    /// Processes a DGML file generated by visual studios architect visualization tools - unused prototype
    /// </summary>
    public class DgmlGenerator
    {
        public DgmlGenerator(string PathToGraphCmdExe, bool DeleteOutputDgmlFile = true)
        {
            pathToGraphCmdExe = PathToGraphCmdExe;
            deleteOutputDgmlFile = DeleteOutputDgmlFile;
            runningStdOutput = new StringBuilder();
            runningStdError = new StringBuilder();
        }


        string pathToGraphCmdExe;
        bool deleteOutputDgmlFile;
        string graphExeParameterFormat = "-input \"{0}\" -output \"{1}\""; //exec \"\"
        string dgmlOutputTempFilename = "temp.dgml";
        StringBuilder runningStdOutput;
        StringBuilder runningStdError;

        public StringBuilder RunningStdOutput
        {
            get { return runningStdOutput; }
        }

        public StringBuilder RunningStdError
        {
            get { return runningStdError; }
        }


        public async Task<string> GetDgml(string pathToDLL, string outputDgmlFilePath)
        {
            var dgml = string.Empty;

            //build input and output paths
            var inputFile = pathToDLL;
            var outputFile = Path.Combine(outputDgmlFilePath, this.dgmlOutputTempFilename);
            var graphCmdParameters = string.Format(this.graphExeParameterFormat, inputFile, outputFile);

            //wait for graphCmd.exe to complete
            await runProcessAsync(Path.GetDirectoryName(pathToGraphCmdExe), Path.GetFileName(pathToGraphCmdExe), graphCmdParameters);

            //ensure output file was created
            if (!File.Exists(outputFile))
                throw new Exception("Output DGML file was not generated. \n\nOUTPUT:\n" + RunningStdOutput.ToString() + "\n\nERROR:\n" + RunningStdError.ToString());

            //read output file
            using (var reader = File.OpenText(outputFile))
                dgml = await reader.ReadToEndAsync();

            //cleanup temp file
            if (deleteOutputDgmlFile && File.Exists(outputFile))
                File.Delete(outputFile);

            //return contents
            return dgml;
        }

        async Task runProcessAsync(string workingDirectory, string fileName, string arguments = null)
        {
            // there is no non-generic TaskCompletionSource
            var tcs = new TaskCompletionSource<bool>();

            var process = new Process
            {
                StartInfo = 
                { 
                    //WorkingDirectory = workingDirectory, 
                    FileName = Path.Combine(workingDirectory, fileName), 
                    Arguments = arguments,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                },
                EnableRaisingEvents = true,
            };

            //log std output
            process.OutputDataReceived += (sender, args) =>
            {
                runningStdOutput.AppendLine(args.Data);
            };

            process.ErrorDataReceived += (sender, args) =>
            {
                runningStdError.AppendLine(args.Data);
            };

            process.Exited += (sender, args) =>
            {
                tcs.SetResult(true);
                process.Dispose();
            };

            process.Start();
            process.BeginOutputReadLine();
            process.BeginErrorReadLine();

            await tcs.Task;

        }

    }
}
