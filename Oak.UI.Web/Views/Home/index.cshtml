@{
}

<div>

	<div id="calltree-panel">

		<div id="pan-box" style="overflow: auto;">
			<div id="paper"></div>
		</div>

		<div id="controls">
			<div id="autocomplete-box" class="input-group">

				<!--logo-->
				<div id="logo">
					<img src="~/Images/oak-logo.jpg" />
				</div>

				<!-- Split button -->
				<div class="btn-group">
					<button type="button" class="btn btn-default dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
						Dev <span class="caret"></span>
					</button>
					<ul class="dropdown-menu">
						<li><a href="#">Environment changer coming soon</a></li>
					</ul>
				</div>

				<!--search box-->
				<div class="typeahead-box">
					<input type="text" id="autocomplete" class="typeahead form-control" placeholder="Search for a database object"
						   onkeypress="if (event.keyCode == 13) { loadGraph(); };" />
				</div>

				<!--generate button-->
				<button class="btn btn-primary" type="button" onclick="javascript:loadGraph();">View</button>

			</div>
			<div id="loading-text"></div>
		</div>

        <!--tips-->
        <div id ="tips">
            <div class="tip"><strong>Tip:</strong> Double click database object to see its definition</div>
        </div>

		<!--legend-->
		<div id="legend">
			<div class="legend-proc">Stored Proc</div>
			<div class="legend-function">Function</div>
			<div class="legend-table">Table</div>
			<div class="legend-view">View</div>
		</div>

		<!--sp definition display-->
		<div id="sp-definition-box">
			<div id="sp-definition-controls">
                <button onclick="showDefinition(currDefinitionText, '100%');">full</button>
                <button onclick="showDefinition(currDefinitionText, '50%');">half</button>
                <button onclick="hideDefinition();">close</button>
            </div>
			<div id="sp-definition-display">
                <pre>
                    <code class="sql"></code>
                </pre>
			</div>
		</div>

	</div>


</div>

@section Styles {
    <link href="~/Styles/bootstrap.min.css" rel="stylesheet" />
    <link href="~/Styles/bootstrap.fixes.css" rel="stylesheet" />
    <link href="~/Styles/joint.min.css" rel="stylesheet" />
    <link href="~/Styles/typeahead.css" rel="stylesheet" />
    <link href="~/Styles/Style.css" rel="stylesheet" />
    <link href="~/Styles/highlight.min.css" rel="stylesheet" />
    <link href="~/Styles/highlight.zenburn.css" rel="stylesheet" />
}
@section ScriptsInHeader {
	<script src="~/Scripts/joint.min.js"></script>
	<script src="~/Scripts/joint.layout.DirectedGraph.min.js"></script>
	<script src="~/Scripts/typeahead.bundle.js"></script>
	<script src="~/Scripts/bootstrap.min.js"></script>
	<script src="~/Scripts/highlight.min.js"></script>
}
@section ScriptsInFooter {
    <script>

        function logMessage(message) {
            console.log(message);
        }

        function displayMessage(message) {
            console.log(message);
            messageLabel.text(message);
        }

        function buildGraphFromAdjacencyList(adjacencyList) {

            elements = [];
            links = [];

            _.each(adjacencyList, function (edges, parentElementLabel) {
                elements.push(makeElement(parentElementLabel));

                _.each(edges, function (childElementLabel) {
                    links.push(makeLink(parentElementLabel, childElementLabel));
                });
            });

            // Links must be added after all the elements. This is because when the links
            // are added to the graph, link source/target
            // elements must be in the graph already.
            return elements.concat(links);
        }

        function makeLink(parentElementLabel, childElementLabel) {

            var newLink = new joint.dia.Link({
                source: { id: parentElementLabel },
                target: { id: childElementLabel },
                attrs: { '.marker-target': { d: 'M 4 0 L 0 2 L 4 4 z' } },
                smooth: smoothLinks,
            });

            return newLink;
        }

        function makeElement(label) {

            var maxLineLength = _.max(label.split('\n'), function (l) { return l.length; }).length;

            //get metadata associated with this db object
            var meta = metadata[label];

            //// Compute width/height of the rectangle based on the number
            //// of lines in the label and the letter size. 0.6 * letterSize is
            //// an approximation of the monospace font letter width.
            var letterSize = 11;
            var width = 1.2 * (letterSize * (0.6 * maxLineLength + 1));
            var height = 1.2 * ((label.split('\n').length + 1) * letterSize);

            var attributes = {
                text: { text: label },
                rect: {
                    rx: 5, ry: 5
                },
            };
            
            var rect = new joint.shapes.basic.Rect({
                id: label,
                size: { width: width, height: height },
                attrs: attributes,
                data: { 'type': meta.type }
            });

            return rect;
        }

        function onPointerDown(evt, x, y) {
            document.getElementsByTagName("body")[0].style.cursor = "-webkit-grabbing";
            isDragging = true;
            lastX = evt.clientX;
            lastY = evt.clientY;
        }

        function onPointerUp(evt, x, y) {
            document.getElementsByTagName("body")[0].style.cursor = "pointer";
            isDragging = false;
        }

        function onMouseMovement(e) {
            if (isDragging) {

                var diffX = e.clientX - lastX;
                var diffY = e.clientY - lastY;
                lastX = e.clientX;
                lastY = e.clientY;

                applyPan(diffX, diffY);
            }
        }

        function onMouseWheel(e) {

            e.preventDefault();
            e = e.originalEvent;

            var zoomAmount;

            //determine mousewheel delta, is set on diff properties for diff browsers
            if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {

                //firefox browsers
                //either +3 / -3, * by 33 to get +99 / -99
                var zoomAmount = e.detail * 30;

            } else {

                //non-firefox browsers
                //either +100 / -100
                var zoomAmount = e.deltaY;
            }

            var isZoomIn = (zoomAmount < 0);

            applyZoom(isZoomIn ? 1.25 : .80);
            //applyZoom(zoom);
        }

        function loadAutocomplete()
        {
            var substringMatcher = function (strs) {
                return function findMatches(q, cb) {
                    var matches, substringRegex;

                    // an array that will be populated with substring matches
                    matches = [];

                    // regex used to determine if a string contains the substring 'q'
                    substrRegex = new RegExp(q, 'i');

                    // iterate through the pool of strings and for any string that
                    // contains the substring 'q', add it to the 'matches' array
                    $.each(strs, function (i, str) {
                        if (substrRegex.test(str)) {
                            matches.push(str);
                        }
                    });

                    cb(matches);
                };
            };

            displayMessage("Loading autocomplete data...");
            console.log(autoCompleteDataUrl);

        	//get graph json
            $.getJSON(autoCompleteDataUrl, function (data) {
        		//console.log(data);

        	    try {
        	        $('#autocomplete.typeahead').typeahead({
        	            hint: true,
        	            highlight: true,
        	            minLength: 2
        	        },
                    {
                        name: 'data',
                        source: substringMatcher(data),
                        limit: 12,
                    });

        	        displayMessage(data.length + " database objects in schema");
        	    }
        	    catch (e) {
        	        displayMessage("Error fetching autocomplete data.");
        	        throw e;
        	    }
        	});
        }

        function loadGraph() {

            var objName = $("#autocomplete").val();

            //need at least 2 characters in box to search on
            if (objName.length < 2) {
                return;
            }

            //build url with parameter
        	var dataUrl = callTreeDataUrl + encodeURIComponent(objName);
        	console.log(dataUrl);

            try
            {
                displayMessage("Getting tree data...");

        	    //get graph json
        	    $.getJSON(dataUrl, function (data) {
        	        //console.log(data);
        	        objects = data.objects;
        	        metadata = data.metadata;
        	        displayMessage("Rendering tree...");

        	        try
        	        {
        	            //generate graph from data
        	            var cells = buildGraphFromAdjacencyList(objects);
        	            graph.resetCells(cells);
        	            joint.layout.DirectedGraph.layout(graph, { setLinkVertices: false });

                        //count entries in data (they're declared as properties but used as a dictionary, this is due to requisite adjacency list format)
        	            var objCount = _.size(objects);

        	            //add css class based on object type
        	            _.each(cells, function (cell) {
        	                var element = paper.findViewByModel(cell);
        	                var attrs = element.model.attributes;
        	                var data = attrs.data;
        	                if (data == undefined) {
        	                    return;
        	                }
        	                var type = data.type;
        	                if (type == undefined) {
        	                    return;
        	                }

        	                //apply css class based on type
        	                V(element.el).addClass("object-base");
        	                V(element.el).addClass("object-" + type); //type (P, T, V)

                            //give tree root special root css class
        	                if (objName == element.model.id) {
        	                    V(element.el).addClass("object-root");
        	                }

							//add doubleclick handler
        	                $(element.el).dblclick(function (evnt) {

								//grab inner text which is object name
        	                	selectedObj = $(this).find("text").text();

        	                	//request and display definition
        	                	loadDef(selectedObj);

        	                });

        	            });

                        //display tree object count
        	            displayMessage(objCount + " item(s) in tree");

                        //reset any pan and zoom in viewer
        	            resetViewer();

        	            //center viewer on root tree object
        	            centerViewerOnRootObject();

        	        } catch (e) {
        	            displayMessage("Rendering tree failed.");
        	            throw e;
        	        }
        	    });

            } catch (e) {
                displayMessage("Getting tree data failed.");
                throw e;
            }
        }


        function loadDef(objName) {

            logMessage("Double clicked: " + objName);

        	//need at least 2 characters in box to search on
        	if (objName.length < 2) {
        		return;
        	}

        	//build url with parameter
        	var dataUrl = definitionDataUrl + encodeURIComponent(objName);
        	logMessage(dataUrl);

        	try {
        	    logMessage("Getting definition data...");

        		//get graph json
        	    $.getJSON(dataUrl)
                    .done(function (data) {
        			    console.log(data);

        			    logMessage("Got definition");

        		        //display definition
        			    showDefinition(data.DefinitionText, "50%");

                    })
                    .fail(function () {

                        logMessage("Getting definition data failed.");

                        //display definition
                        showDefinition("-- Sorry! The definition for this object could not be retrieved...", "50%");
                    });

        	} catch (e) {
        	    logMessage("Getting definition data failed.");
        		throw e;
        	}
        }

        function onWindowResized() {
            $(paper.svg).width(panBox.width() - (panBoxPaddingX));
            $(paper.svg).height(panBox.height() - (panBoxPaddingY));
        }

        function applyZoom(scale) {
            //console.log("zoom " + scale);

            //scale matrix values
            for (var i = 0; i < viewportMatrix.length; i++) {
                viewportMatrix[i] *= scale;
            }
            viewportMatrix[4] += (1 - scale) * $(paper.svg).width() / 2;
            viewportMatrix[5] += (1 - scale) * $(paper.svg).height() / 2;
            updateSvgTransform();
        }

        function applyPan(deltaX, deltaY) {
            //console.log("pan " + deltaX + ", " + deltaY);

            //update pan on matrix
            viewportMatrix[4] += deltaX;
            viewportMatrix[5] += deltaY;
            updateSvgTransform();
        }

        function resetViewer() {
            //reset all pan and zoom from matrix
            viewportMatrix = [1, 0, 0, 1, 0, 0];
            updateSvgTransform();
        }

        function centerViewerOnRootObject() {
            
            var screen = $(paper.el);
            var graph = V(paper.viewport).bbox();

            //center x
            var panX = (screen.width() / 2) - (graph.width / 2);
            //33% from top of available screen
            var panY = (screen.height() / 3) - (graph.height / 2);

            applyPan(panX, panY);

        }

        function updateSvgTransform() {
            //build and update transform matrix
            var txValue = "matrix(" + viewportMatrix.join(' ') + ")";
            V(paper.viewport).attr('transform', txValue);
        }

        function showDefinition(definition, paneWidth) {
            currDefinitionText = definition;

            //show panel
            var defPanel = $("#sp-definition-box");
            defPanel.css("width", paneWidth);
            defPanel.show(300);

            //display def
            var def = $("#sp-definition-box code");
            def.text(currDefinitionText);

            //apply highlighting
            $('pre code').each(function (i, block) {
                hljs.highlightBlock(block);
            });

        }

        function hideDefinition() {

            //hide panel
            var defPanel = $("#sp-definition-box");
            defPanel.hide(100);

            //clear def
            var def = $("#sp-definition");
            def.text('');
        }


        //configuration
        var smoothLinks = true;
        var autoCompleteDataUrl = "api/schema/autocomplete";
        var callTreeDataUrl = "api/schema/dependencytree/?objName="
        var definitionDataUrl = "api/schema/definition/?objName="

        var graph;
        var objects = [];
        var metadata = [];
        var elements = [];
        var links = [];
        var isDragging = false;
        var container;
        var origPaperWidth;
        var origPaperHeight;
        var panBox;
        var panBoxPaddingX = 20;
        var panBoxPaddingY = 10;
        var paper;
        var lastX = 0;
        var lastY = 0;
        var viewportMatrix = [1, 0, 0, 1, 0, 0];
        var messageLabel;
        var currDefinitionText = "";
        var selectedObj;

        $(document).ready(function () {

            //hide def panel
            hideDefinition();

            //setup graph api
            graph = new joint.dia.Graph
            container = $("#paper");
            panBox = $("#pan-box");
            messageLabel = $("#loading-text");

            origPaperWidth = (panBox.width());
            origPaperHeight = (panBox.height());

            paper = new joint.dia.Paper({
                el: $('#paper'),
                width: (origPaperWidth - panBoxPaddingX),
                height: (origPaperHeight - panBoxPaddingY),
                gridSize: 1,
                model: graph,
                snapLinks: false,
            });

            paper.setOrigin(300, 200);

            //handle resize window
            $(window).resize(onWindowResized);

            //zoom support
            paper.$el.on('mousewheel DOMMouseScroll', onMouseWheel);

            //panning support
            paper.on('blank:pointerdown', onPointerDown);
            paper.on('blank:pointerup', onPointerUp);
            $(document).mousemove(onMouseMovement);

            //get autocomplete data
            loadAutocomplete();

            //update viewport transforms with default settings
            updateSvgTransform();

            //attempted fix at centering the scaling origin on svg viewport
            //V(paper.viewport).attr('preserveAspectRatio', 'xMidYMin slice');

        });


    </script>
}